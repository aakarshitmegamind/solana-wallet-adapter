/// Imports
/// ------------------------------------------------------------------------------------------------

import 'dart:convert';
import 'dart:typed_data';
import 'package:solana_common/utils/buffer.dart';
import 'package:solana_common/utils/library.dart';
import 'package:webcrypto/webcrypto.dart';
import '../crypto/association_token.dart';
import '../crypto/association_keypair.dart';
import '../crypto/session_keypair.dart';
import '../crypto/shared_secrey_key.dart';
import '../exceptions/solana_wallet_adapter_exception.dart';


/// Wallet Adapter Session
/// ------------------------------------------------------------------------------------------------

class WalletAdapterSession {

  /// Manages the keys and encryption of a mobile wallet adapter session.
  WalletAdapterSession();

  /// The dApp endpoint's monotonically increasing message sequence number, which starts at 1.
  int _dAppSequenceNumber = 0;

  /// The wallet endpoint's monotonically increasing message sequence number, which starts at 1.
  int _walletSequenceNumber = 0;

  /// The initialisation vector's byte length.
  static const int aesIvByteLength = 12;

  /// The message authentication code's bit length.
  static const int aesTagBitLength = 16 * 8; // 128-bits.
  
  /// The sequence number's byte length.
  static const int sequenceNumberByteLength = 4;

  /// The shared secret's bit length.
  static const int sharedSecretBitLength = 32 * 8; // 256-bits.

  /// The AES-128-GCM shared secret key's bit length.
  static const int aesGcmSecretKeyBitLength = 16 * 8; // 128-bits.

  /// An `ephemeral` ECDSA keypair on the P-256 curve, generated by the dApp endpoint.
  AssociationKeypair? associationKeypair;

  /// An `ephemeral` ECDH keypair on the P-256 curve, generated by the dApp endpoint.
  SessionKeypair? sessionKeypair;

  /// An `ephemeral` AES-128-GCM secret key, calculated by the dApp and wallet endpoints.
  SharedSecretKey? sharedSecretKey;

  /// True if a [sharedSecretKey] has been generated for the current session (see 
  /// [generateSharedSecretKey]).
  bool get isEncrypted => sharedSecretKey != null;

  /// A base-64 URL encoding of the [associationKeypair]s X9.62 public key format. An 
  /// [associationKeypair] must be created using [generateAssociationKeypair] before accessing this 
  /// property.
  Future<AssociationToken> get associationToken 
    => associationKeypair?.token() ?? Future.error(_keyNotGeneratedException(AssociationKeypair));

  /// Discards all keys for the current session.
  void dispose() {
    associationKeypair = null;
    sessionKeypair = null;
    sharedSecretKey = null;
  }

  /// Returns an `invalid session` exception.
  SolanaWalletAdapterException _keyException(
    final String message, 
  ) => SolanaWalletAdapterException(
      message,
      code: SolanaWalletAdapterExceptionCode.sessionKeypair,
    );

  /// Returns an exception for a [key] that has already been created.
  SolanaWalletAdapterException _keyGeneratedException<T>(final T key)
    => _keyException('[$T] has `already` been generated for the current session.');

  /// Returns an exception for a [key] that has not been created.
  SolanaWalletAdapterException _keyNotGeneratedException<T>(final T? key)
    => _keyException('[$T] has `not` been generated for the current session.');

  /// Throws an exception if [key] is `null`.
  /// 
  /// Returns [key].
  T _checkKeyGenerated<T>(final T? key) => key ?? (throw _keyNotGeneratedException(key));

  /// Throws an exception if [key] is not `null`.
  /// 
  /// Returns [key].
  void _checkKeyNotGenerated<T>(final T? key)
    => key != null ? throw _keyGeneratedException(key) : null;

  /// Creates an [associationKeypair] for the current session. A new [associationKeypair] must be 
  /// created every time a dApp endpoint seeks to connect to a wallet endpoint.
  Future<void> generateAssociationKeypair() async {
    _checkKeyNotGenerated(associationKeypair);
    associationKeypair = await AssociationKeypair.generate();
  }

  /// Creates a [sessionKeypair] for the current session. A new [sessionKeypair] must be created 
  /// every time a dApp endpoint seeks to exchange keys with a wallet endpoint.
  Future<void> generateSessionKeypair() async {
    _checkKeyNotGenerated(sessionKeypair);
    sessionKeypair = await EcdhPrivateKey.generateKey(EllipticCurve.p256);
  }

  /// Creates a `hello request` message, which is the first message sent after a connection has been 
  /// established between the dApp and wallet endpoint, and begins a Diffie-Hellman-Merkle key 
  /// exchange.
  Future<Uint8List> generateHelloRequest() async {
    checkEq(_walletSequenceNumber, 0, 'wallet sequence number');
    final EcdhPublicKey sessionPublicKey = _checkKeyGenerated(sessionKeypair).publicKey;
    final EcdsaPrivateKey associationPrivateKey = _checkKeyGenerated(associationKeypair).privateKey;
    final Uint8List rawKey = await sessionPublicKey.exportRawKey();
    final Uint8List signature = await associationPrivateKey.signBytes(rawKey, Hash.sha256);
    final int length = rawKey.length + signature.length;
    return Uint8List(length)..setAll(0, rawKey)..setAll(rawKey.length, signature);
  }

  /// Parses a `hello response` [message] to generate a [sharedSecretKey] using the [sessionKeypair] 
  /// and [associationKeypair]. 
  /// 
  /// The [message] should be the first message received after a connection has been established 
  /// between the dApp and wallet endpoints.
  Future<void> generateSharedSecretKey(
    final List<int> message,
  ) async {
    final EcdhPrivateKey sessionPrivateKey = _checkKeyGenerated(sessionKeypair).privateKey;
    final EcdsaPublicKey associationPublicKey = _checkKeyGenerated(associationKeypair).publicKey;

    final List<Object> keys = await Future.wait([
      associationPublicKey.exportRawKey(),
      EcdhPublicKey.importRawKey(message, EllipticCurve.p256)
    ]);

    final Uint8List associationPublicKeyBuffer = keys[0] as Uint8List;
    final EcdhPublicKey walletPublicKey = keys[1] as EcdhPublicKey;

    const int bitLength = sharedSecretBitLength;
    final Uint8List sharedSecret = await sessionPrivateKey.deriveBits(bitLength, walletPublicKey);
    final HkdfSecretKey secretKey = await HkdfSecretKey.importRawKey(sharedSecret);

    final Uint8List sharedSecretKeyBuffer = await secretKey.deriveBits(
      aesGcmSecretKeyBitLength, Hash.sha256, associationPublicKeyBuffer, const [],
    );
    sharedSecretKey = await AesGcmSecretKey.importRawKey(sharedSecretKeyBuffer);
  }

  /// Encrypts [message] using the derived [sharedSecretKey] (see [generateSharedSecretKey]).
  Future<Uint8List> encrypt(final List<int> message) async {
    
    // Check that a shared secret key has been generated for the session.
    final SharedSecretKey sharedSecretKey = _checkKeyGenerated(this.sharedSecretKey);

    // Create a buffer containing the dApp's sequence number.
    final Buffer sequenceNumber = Buffer(sequenceNumberByteLength)
      ..setUint32(++_dAppSequenceNumber, 0, Endian.big);
    checkGte(_dAppSequenceNumber, 1, 'dApp sequence number');

    // Generate a 12-byte buffer with random values.
    final Buffer initialisationVector = Buffer.random(aesIvByteLength);
    
    // Encrypt the [message] using the [sharedSecretKey].
    final Uint8List cipherText = await sharedSecretKey.encryptBytes(
      message, 
      initialisationVector.asUint8List(), 
      additionalData: sequenceNumber.asUint8List(), 
      tagLength: aesTagBitLength,
    );

    return (sequenceNumber + initialisationVector + cipherText).asUint8List();
  }

  /// Decrypts [message] using the derived [sharedSecretKey] (see [generateSharedSecretKey]).
  Future<Map<String, dynamic>> decrypt(final List<int> message) async {

    // Check that a shared secret key has been generated for the session.
    final SharedSecretKey sharedSecretKey = _checkKeyGenerated(this.sharedSecretKey);

    // Create a [BufferReader] over the [message].
    final BufferReader reader = BufferReader.fromList(message);

    // Get the message sequence number, a 4-byte big-endian unsigned integer.
    final Buffer sequenceNumberBuffer = reader.get(sequenceNumberByteLength);
    final int sequenceNumber = sequenceNumberBuffer.getUint32(0, Endian.big);
    checkGt(sequenceNumber, _walletSequenceNumber, 'wallet sequence number');
    _walletSequenceNumber = sequenceNumber;

    // Get the initialisation vector, a randomly generated list of 12 8-bit unsigned integers 
    // (which should be created for each encrypted message).
    final Buffer initialisationVector = reader.get(aesIvByteLength);

    // Get the AES-128-GCM message ciphertext (i.e. the remaining contents).
    final Buffer ciphertext = reader.get();

    // Decrypt the ciphertext using the [sharedSecretKey].
    final Uint8List plainText = await sharedSecretKey.decryptBytes(
      ciphertext.asUint8List(), 
      initialisationVector.asUint8List(), 
      additionalData: sequenceNumberBuffer.asUint8List(), 
      tagLength: aesTagBitLength,
    );

    return json.decode(utf8.decode(plainText));
  }
}